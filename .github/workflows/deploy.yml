name: CI/CD Pipeline - Voting App

on:
  pull_request:
    paths:
      - 'docker/**'
      - 'kubernetes/**'
      - '.github/workflows/deploy.yml'

env:
  AWS_REGION: us-west-2
  ECR_REPOSITORY: voting-app
  EKS_CLUSTER_NAME: voting-app-cluster

jobs:
  # Job 1: Build and Test Docker Images
  build-and-test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push vote image
      working-directory: ./docker/voting-app/vote
      run: |
        docker build -t ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}/vote:${{ github.sha }} .
        docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}/vote:${{ github.sha }}

    - name: Build and push result image
      working-directory: ./docker/voting-app/result
      run: |
        docker build -t ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}/result:${{ github.sha }} .
        docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}/result:${{ github.sha }}

    - name: Build and push worker image
      working-directory: ./docker/voting-app/worker
      run: |
        docker build -t ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}/worker:${{ github.sha }} .
        docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}/worker:${{ github.sha }}

    - name: Run basic tests
      run: |
        # Test if images can be pulled
        docker pull ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}/vote:${{ github.sha }}
        docker pull ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}/result:${{ github.sha }}
        docker pull ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}/worker:${{ github.sha }}

  # Job 3: Deploy to Kubernetes
  deploy:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.ref == 'refs/heads/main'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kubeconfig
      run: aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

    - name: Get RDS Password from Secrets Manager
      id: get-db-password
      run: |
        SECRET_ARN=$(terraform -chdir=./terraform/environments/prod output -raw db_master_user_secret_arn)
        PASSWORD=$(aws secretsmanager get-secret-value --secret-id $SECRET_ARN --query SecretString --output text | jq -r .password)
        echo "db_password=$PASSWORD" >> $GITHUB_OUTPUT

    - name: Create Kubernetes secrets
      run: |
        # Create database credentials secret
        kubectl create secret generic db-credentials \
          --from-literal=database-url="postgresql://postgres:${{ secrets.RDS_DB_PASSWORD }}@$(terraform -chdir=./terraform/environments/prod output -raw db_instance_endpoint):5432/votingapp" \
          --namespace=voting-app \
          --dry-run=client -o yaml | kubectl apply -f -

        # Create Docker registry secret
        kubectl create secret docker-registry docker-registry-secret \
          --docker-server=${{ steps.login-ecr.outputs.registry }} \
          --docker-username=AWS \
          --docker-password=$(aws ecr get-login-password --region ${{ env.AWS_REGION }}) \
          --namespace=voting-app \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy application
      run: |
        # Apply namespaces
        kubectl apply -f kubernetes/namespaces/
        
        # Apply deployments
        kubectl apply -f kubernetes/deployments/
        
        # Apply services
        kubectl apply -f kubernetes/services/
        
        # Apply ingress
        kubectl apply -f kubernetes/ingress/

    - name: Wait for deployments
      run: |
        kubectl wait --for=condition=available --timeout=300s deployment/vote -n voting-app
        kubectl wait --for=condition=available --timeout=300s deployment/result -n voting-app
        kubectl wait --for=condition=available --timeout=300s deployment/worker -n voting-app

    - name: Run post-deployment tests
      run: |
        # Test if services are responding
        kubectl get pods -n voting-app
        kubectl get services -n voting-app
        kubectl get ingress -n voting-app

  # Job 4: Monitoring and Alerting
  monitoring:
    runs-on: ubuntu-latest
    needs: deploy
    if: github.ref == 'refs/heads/main'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kubeconfig
      run: aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

    - name: Deploy monitoring stack
      run: |
        # Add Prometheus Helm repository
        helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
        helm repo update
        
        # Install Prometheus stack
        helm install prometheus prometheus-community/kube-prometheus-stack \
          --namespace monitoring \
          --create-namespace \
          --set grafana.enabled=true \
          --set prometheus.enabled=true \
          --set alertmanager.enabled=true

    - name: Verify monitoring deployment
      run: |
        kubectl get pods -n monitoring
        kubectl get services -n monitoring 